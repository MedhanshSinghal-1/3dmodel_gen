import * as THREE from 'three';

interface Room {
  id: string;
  name: string;
  color: string;
  vertices: Array<[number, number]>;
  center: [number, number];
}

interface ProcessedData {
  rooms: Room[];
  walls: Array<Array<[number, number]>>;
  originalImage: string;
  processedImage: string;
}

/**
 * 3D Model Export utilities
 */
export class ModelExporter {
  
  /**
   * Export model to OBJ format
   */
  static exportToOBJ(processedData: ProcessedData): string {
    let obj = '# 3D Floor Plan Model\n';
    obj += '# Generated by Floor Plan 3D Converter\n\n';

    let vertexIndex = 1;
    
    // Export rooms as floor planes
    for (const room of processedData.rooms) {
      obj += `# Room: ${room.name}\n`;
      obj += `g ${room.name.replace(/\s+/g, '_')}\n`;
      
      // Add vertices for room floor
      for (const vertex of room.vertices) {
        obj += `v ${vertex[0]} 0 ${vertex[1]}\n`;
      }
      
      // Add face for room floor
      const faceIndices = [];
      for (let i = 0; i < room.vertices.length; i++) {
        faceIndices.push(vertexIndex + i);
      }
      obj += `f ${faceIndices.join(' ')}\n\n`;
      
      vertexIndex += room.vertices.length;
    }

    // Export walls
    obj += '# Walls\n';
    obj += 'g Walls\n';
    
    for (let i = 0; i < processedData.walls.length; i++) {
      const wall = processedData.walls[i];
      if (wall.length < 2) continue;
      
      const [start, end] = wall;
      const wallHeight = 25;
      
      // Wall vertices (bottom and top)
      obj += `v ${start[0]} 0 ${start[1]}\n`;
      obj += `v ${end[0]} 0 ${end[1]}\n`;
      obj += `v ${end[0]} ${wallHeight} ${end[1]}\n`;
      obj += `v ${start[0]} ${wallHeight} ${start[1]}\n`;
      
      // Wall faces (2 triangles forming a rectangle)
      obj += `f ${vertexIndex} ${vertexIndex + 1} ${vertexIndex + 2}\n`;
      obj += `f ${vertexIndex} ${vertexIndex + 2} ${vertexIndex + 3}\n`;
      
      vertexIndex += 4;
    }

    return obj;
  }

  /**
   * Export model to STL format (ASCII)
   */
  static exportToSTL(processedData: ProcessedData): string {
    let stl = 'solid FloorPlan3DModel\n';

    // Export rooms as floor triangles
    for (const room of processedData.rooms) {
      for (let i = 0; i < room.vertices.length - 2; i++) {
        const v1 = room.vertices[0];
        const v2 = room.vertices[i + 1];
        const v3 = room.vertices[i + 2];
        
        // Calculate normal (pointing up)
        stl += `  facet normal 0.0 1.0 0.0\n`;
        stl += `    outer loop\n`;
        stl += `      vertex ${v1[0]} 0.0 ${v1[1]}\n`;
        stl += `      vertex ${v2[0]} 0.0 ${v2[1]}\n`;
        stl += `      vertex ${v3[0]} 0.0 ${v3[1]}\n`;
        stl += `    endloop\n`;
        stl += `  endfacet\n`;
      }
    }

    // Export walls
    for (const wall of processedData.walls) {
      if (wall.length < 2) continue;
      
      const [start, end] = wall;
      const wallHeight = 25;
      
      // Wall consists of 2 triangles
      const v1 = [start[0], 0, start[1]];
      const v2 = [end[0], 0, end[1]];
      const v3 = [end[0], wallHeight, end[1]];
      const v4 = [start[0], wallHeight, start[1]];
      
      // Calculate wall normal
      const wallVector = [end[0] - start[0], 0, end[1] - start[1]];
      const upVector = [0, 1, 0];
      const normal = [
        wallVector[2] * upVector[1] - wallVector[1] * upVector[2],
        wallVector[0] * upVector[2] - wallVector[2] * upVector[0],
        wallVector[1] * upVector[0] - wallVector[0] * upVector[1]
      ];
      
      // Normalize
      const length = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);
      normal[0] /= length;
      normal[1] /= length;
      normal[2] /= length;
      
      // First triangle
      stl += `  facet normal ${normal[0]} ${normal[1]} ${normal[2]}\n`;
      stl += `    outer loop\n`;
      stl += `      vertex ${v1[0]} ${v1[1]} ${v1[2]}\n`;
      stl += `      vertex ${v2[0]} ${v2[1]} ${v2[2]}\n`;
      stl += `      vertex ${v3[0]} ${v3[1]} ${v3[2]}\n`;
      stl += `    endloop\n`;
      stl += `  endfacet\n`;
      
      // Second triangle
      stl += `  facet normal ${normal[0]} ${normal[1]} ${normal[2]}\n`;
      stl += `    outer loop\n`;
      stl += `      vertex ${v1[0]} ${v1[1]} ${v1[2]}\n`;
      stl += `      vertex ${v3[0]} ${v3[1]} ${v3[2]}\n`;
      stl += `      vertex ${v4[0]} ${v4[1]} ${v4[2]}\n`;
      stl += `    endloop\n`;
      stl += `  endfacet\n`;
    }

    stl += 'endsolid FloorPlan3DModel\n';
    return stl;
  }

  /**
   * Export model to GLTF format (simplified)
   */
  static exportToGLTF(processedData: ProcessedData): object {
    const vertices: number[] = [];
    const indices: number[] = [];
    const normals: number[] = [];
    const colors: number[] = [];
    
    let vertexIndex = 0;

    // Process rooms
    for (const room of processedData.rooms) {
      const color = this.hexToRgb(room.color);
      
      // Add vertices for room floor
      for (const vertex of room.vertices) {
        vertices.push(vertex[0], 0, vertex[1]);
        normals.push(0, 1, 0); // Floor normal pointing up
        colors.push(color.r / 255, color.g / 255, color.b / 255, 0.8);
      }
      
      // Add triangular faces for room floor
      for (let i = 0; i < room.vertices.length - 2; i++) {
        indices.push(vertexIndex, vertexIndex + i + 1, vertexIndex + i + 2);
      }
      
      vertexIndex += room.vertices.length;
    }

    // Process walls
    for (const wall of processedData.walls) {
      if (wall.length < 2) continue;
      
      const [start, end] = wall;
      const wallHeight = 25;
      
      // Wall vertices
      const wallVertices = [
        [start[0], 0, start[1]],
        [end[0], 0, end[1]],
        [end[0], wallHeight, end[1]],
        [start[0], wallHeight, start[1]]
      ];
      
      // Calculate wall normal
      const wallVector = [end[0] - start[0], 0, end[1] - start[1]];
      const length = Math.sqrt(wallVector[0] * wallVector[0] + wallVector[2] * wallVector[2]);
      const normal = [-wallVector[2] / length, 0, wallVector[0] / length];
      
      for (const vertex of wallVertices) {
        vertices.push(vertex[0], vertex[1], vertex[2]);
        normals.push(normal[0], normal[1], normal[2]);
        colors.push(0.8, 0.8, 0.8, 1.0); // Gray walls
      }
      
      // Wall faces (2 triangles)
      indices.push(vertexIndex, vertexIndex + 1, vertexIndex + 2);
      indices.push(vertexIndex, vertexIndex + 2, vertexIndex + 3);
      
      vertexIndex += 4;
    }

    // Create GLTF structure
    const gltf = {
      asset: {
        version: "2.0",
        generator: "Floor Plan 3D Converter"
      },
      scenes: [{ nodes: [0] }],
      nodes: [{ mesh: 0 }],
      meshes: [{
        primitives: [{
          attributes: {
            POSITION: 0,
            NORMAL: 1,
            COLOR_0: 2
          },
          indices: 3
        }]
      }],
      accessors: [
        {
          bufferView: 0,
          componentType: 5126, // FLOAT
          count: vertices.length / 3,
          type: "VEC3",
          min: [Math.min(...vertices.filter((_, i) => i % 3 === 0)), 0, Math.min(...vertices.filter((_, i) => i % 3 === 2))],
          max: [Math.max(...vertices.filter((_, i) => i % 3 === 0)), 25, Math.max(...vertices.filter((_, i) => i % 3 === 2))]
        },
        {
          bufferView: 1,
          componentType: 5126, // FLOAT
          count: normals.length / 3,
          type: "VEC3"
        },
        {
          bufferView: 2,
          componentType: 5126, // FLOAT
          count: colors.length / 4,
          type: "VEC4"
        },
        {
          bufferView: 3,
          componentType: 5123, // UNSIGNED_SHORT
          count: indices.length,
          type: "SCALAR"
        }
      ],
      bufferViews: [
        {
          buffer: 0,
          byteOffset: 0,
          byteLength: vertices.length * 4
        },
        {
          buffer: 0,
          byteOffset: vertices.length * 4,
          byteLength: normals.length * 4
        },
        {
          buffer: 0,
          byteOffset: (vertices.length + normals.length) * 4,
          byteLength: colors.length * 4
        },
        {
          buffer: 0,
          byteOffset: (vertices.length + normals.length + colors.length) * 4,
          byteLength: indices.length * 2
        }
      ],
      buffers: [{
        byteLength: (vertices.length + normals.length + colors.length) * 4 + indices.length * 2
      }]
    };

    return gltf;
  }

  /**
   * Convert hex color to RGB
   */
  private static hexToRgb(hex: string): { r: number; g: number; b: number } {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : { r: 255, g: 255, b: 255 };
  }

  /**
   * Download file with given content
   */
  static downloadFile(content: string, filename: string, mimeType: string = 'text/plain'): void {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  /**
   * Download JSON file
   */
  static downloadJSON(data: object, filename: string): void {
    const content = JSON.stringify(data, null, 2);
    this.downloadFile(content, filename, 'application/json');
  }

  /**
   * Export and download model in specified format
   */
  static exportModel(processedData: ProcessedData, format: 'obj' | 'stl' | 'gltf'): void {
    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
    
    switch (format) {
      case 'obj':
        const objContent = this.exportToOBJ(processedData);
        this.downloadFile(objContent, `floorplan_3d_${timestamp}.obj`, 'text/plain');
        break;
        
      case 'stl':
        const stlContent = this.exportToSTL(processedData);
        this.downloadFile(stlContent, `floorplan_3d_${timestamp}.stl`, 'text/plain');
        break;
        
      case 'gltf':
        const gltfData = this.exportToGLTF(processedData);
        this.downloadJSON(gltfData, `floorplan_3d_${timestamp}.gltf`);
        break;
        
      default:
        console.error('Unsupported export format:', format);
    }
  }
}

export default ModelExporter;